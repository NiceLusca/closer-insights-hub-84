
import type { Lead, DateRange, Filters } from "@/types/lead";

export interface FilterContext {
  isTemporalFilter?: boolean;
  component?: string;
}

// Fun칞칚o auxiliar para converter parsedDate em Date se necess치rio
function ensureDateObject(dateValue: any): Date | null {
  if (!dateValue) return null;
  
  if (dateValue instanceof Date) {
    return dateValue;
  }
  
  if (typeof dateValue === 'string') {
    const parsed = new Date(dateValue);
    return isNaN(parsed.getTime()) ? null : parsed;
  }
  
  return null;
}

export function filterLeads(
  leads: Lead[], 
  dateRange: DateRange, 
  filters: Filters,
  context: FilterContext = {}
): Lead[] {
  const { isTemporalFilter = false, component = 'unknown' } = context;
  
  console.log(`游댌 [${component.toUpperCase()}] === FILTRO CORRIGIDO (MENOS RESTRITIVO) ===`);
  console.log(`游댌 [${component.toUpperCase()}] Total de leads recebidos:`, leads.length);
  console.log(`游댌 [${component.toUpperCase()}] Per칤odo selecionado:`, {
    from: dateRange.from.toLocaleDateString(),
    to: dateRange.to.toLocaleDateString()
  });
  console.log(`游댌 [${component.toUpperCase()}] Filtros ativos:`, filters);
  
  const filtered = leads.filter(lead => {
    // CORRE칂츾O CR칈TICA 1: Ser MUITO menos restritivo com status
    // Incluir leads mesmo sem status se n칚o h치 filtros espec칤ficos
    const leadStatus = lead.Status?.trim();
    
    if (filters.status.length > 0) {
      // S칩 filtrar por status se h치 filtros espec칤ficos selecionados
      if (leadStatus && !filters.status.includes(leadStatus)) {
        return false;
      }
    }
    // Se n칚o h치 filtros de status, incluir TODOS os leads (mesmo sem status)
    
    // 2. Filtrar por closer (menos restritivo)
    if (filters.closer.length > 0) {
      const leadCloser = lead.Closer?.trim() || '';
      if (leadCloser && !filters.closer.includes(leadCloser)) {
        return false;
      }
      // Se lead n칚o tem closer mas filtro est치 ativo, ainda incluir
    }
    
    // 3. Filtrar por origem (menos restritivo)
    if (filters.origem.length > 0) {
      const leadOrigem = lead.origem?.trim() || '';
      if (leadOrigem && !filters.origem.includes(leadOrigem)) {
        return false;
      }
      // Se lead n칚o tem origem mas filtro est치 ativo, ainda incluir
    }
    
    // 4. CORRE칂츾O CR칈TICA 2: Filtrar por data com fallbacks robustos
    const safeDate = ensureDateObject(lead.parsedDate);
    if (safeDate) {
      const leadDate = new Date(safeDate);
      
      // VALIDA칂츾O CR칈TICA: Rejeitar datas muito antigas (antes de 2020)
      if (leadDate.getFullYear() < 2020) {
        console.warn(`丘멆잺 [${component}] Data rejeitada por ser muito antiga:`, leadDate.toISOString().split('T')[0], 'Lead:', lead.Nome);
        return false;
      }
      
      const fromDate = new Date(dateRange.from);
      const toDate = new Date(dateRange.to);
      
      leadDate.setHours(0, 0, 0, 0);
      fromDate.setHours(0, 0, 0, 0);
      toDate.setHours(23, 59, 59, 999);
      
      const dentroDoRange = leadDate >= fromDate && leadDate <= toDate;
      
      if (!dentroDoRange) {
        return false;
      }
    } else {
      // CORRE칂츾O CR칈TICA 3: Tentar usar campo 'data' como fallback
      if (lead.data && lead.data.trim() !== '') {
        try {
          const dataAlternativa = new Date(lead.data);
          if (!isNaN(dataAlternativa.getTime())) {
            // VALIDA칂츾O: Rejeitar datas muito antigas
            if (dataAlternativa.getFullYear() < 2020) {
              console.warn(`丘멆잺 [${component}] Data alternativa rejeitada por ser muito antiga:`, dataAlternativa.toISOString().split('T')[0]);
              return false;
            }
            
            const leadDate = new Date(dataAlternativa);
            const fromDate = new Date(dateRange.from);
            const toDate = new Date(dateRange.to);
            
            leadDate.setHours(0, 0, 0, 0);
            fromDate.setHours(0, 0, 0, 0);
            toDate.setHours(23, 59, 59, 999);
            
            const dentroDoRange = leadDate >= fromDate && leadDate <= toDate;
            
            if (!dentroDoRange) {
              return false;
            }
          }
        } catch (e) {
          // Para an치lises n칚o temporais, incluir leads sem data v치lida
          if (isTemporalFilter) {
            return false;
          }
        }
      } else {
        // Para an치lises temporais, excluir leads completamente sem data
        if (isTemporalFilter) {
          return false;
        }
      }
    }
    
    return true;
  });
  
  console.log(`游늵 [${component}] RESULTADO FINAL (CORRIGIDO):`);
  console.log(`游늵 [${component}] - Total antes: ${leads.length}`);
  console.log(`游늵 [${component}] - Total depois: ${filtered.length}`);
  console.log(`游늵 [${component}] - Filtros aplicados de forma menos restritiva`);
  
  return filtered;
}

// Fun칞칚o espec칤fica para filtros temporais (gr치ficos)
export function filterLeadsForTemporal(
  leads: Lead[], 
  dateRange: DateRange, 
  filters: Filters,
  component: string = 'temporal'
): Lead[] {
  return filterLeads(leads, dateRange, filters, { 
    isTemporalFilter: true, 
    component 
  });
}

// Fun칞칚o para validar se os filtros fazem sentido
export function validateFilters(
  leads: Lead[], 
  dateRange: DateRange, 
  filters: Filters
): {
  isValid: boolean;
  warnings: string[];
  suggestions: string[];
} {
  const warnings: string[] = [];
  const suggestions: string[] = [];
  
  // CORRE칂츾O: Ser menos restritivo na valida칞칚o
  const leadsWithAnyData = leads.filter(lead => {
    return lead.Nome?.trim() || lead.Status?.trim() || lead.origem?.trim() || lead.Closer?.trim();
  });
  
  if (leadsWithAnyData.length === 0) {
    warnings.push('Nenhum lead com dados b치sicos encontrado');
    suggestions.push('Verifique se os dados est칚o sendo importados corretamente');
    return { isValid: false, warnings, suggestions };
  }
  
  // Verificar se h치 leads no per칤odo (menos restritivo)
  const leadsInDateRange = leads.filter(lead => {
    const safeDate = ensureDateObject(lead.parsedDate);
    if (!safeDate) return false;
    
    const leadDate = new Date(safeDate);
    // Rejeitar apenas datas obviamente inv치lidas
    if (leadDate.getFullYear() < 2020) return false;
    
    return leadDate >= dateRange.from && leadDate <= dateRange.to;
  });
  
  if (leadsInDateRange.length === 0) {
    warnings.push('Poucos leads encontrados no per칤odo selecionado');
    suggestions.push('Considere expandir o per칤odo de data ou verificar filtros');
  }
  
  return {
    isValid: warnings.length === 0,
    warnings,
    suggestions
  };
}
